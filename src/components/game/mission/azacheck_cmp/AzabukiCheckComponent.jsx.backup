import { useEffect, useState, useRef } from 'react'
import { useParams } from 'react-router-dom'
import { createTypingAnimation } from '@/utils/typingAnimation'
import { useDeviceRotation } from '@/utils/deviceRotation'
import { FaPlay } from 'react-icons/fa'
import './azabukiCheckComponent.css'
import { saveMissionProgressUniversal } from '@/utils/missionProgressUtils'
// Removed the local import of mission data since we're getting it from props

const AzabukiCheckComponent = ({
  missionData,
  onComplete,
  voiceNarration,
  characterImage,
  interfaceBG,
  currentStep
}) => {
  const [titleText, setTitleText] = useState('')
  const [typedContent, setTypedContent] = useState('')
  const [isTypingContent, setIsTypingContent] = useState(false)
  const [showControls, setShowControls] = useState(false)
  const [audioDuration, setAudioDuration] = useState(0)
  const typingAnimationController = useRef(null)
  const textContainerRef = useRef(null) // Ref for the text area if needed for scrolling
  const audioRef = useRef(new Audio())
  const { missionId } = useParams()
  // Use the rotation hook
  const needsRotation = useDeviceRotation()

  // --- Placeholder Functions (Implement or Remove if not needed) ---
  const playSoundEffect = (type) => {
    console.log(`Playing sound: ${type}`) // Replace with actual sound logic
  }

  const saveProgress = async () => {
    const missionDatas = {
      missionId: missionId,
      step: currentStep,
      progress: 30
    }
    await saveMissionProgressUniversal(missionDatas)
  }

  // Function to start typing animation with audio duration
  const startTypingAnimation = (content, duration) => {
    // Stop any previous animation
    if (typingAnimationController.current) {
      typingAnimationController.current.stop()
    }

    // Reset states before starting new animation
    setTypedContent('')
    setIsTypingContent(true)
    setShowControls(false)

    // Create and start the typing animation controller with actual audio duration
    typingAnimationController.current = createTypingAnimation({
      content: content,
      durationSeconds: duration,
      onUpdate: (newTypedContent) => {
        setTypedContent(newTypedContent)
        // Auto-scroll logic (optional)
        if (textContainerRef.current) {
          textContainerRef.current.scrollTop =
            textContainerRef.current.scrollHeight
        }
      },
      onComplete: () => {
        setIsTypingContent(false)
        playSoundEffect('complete')
        setTimeout(() => setShowControls(true), 500)
      },
      onTick: () => {
        // playSoundEffect('typing') // Maybe too noisy? Uncomment if needed
      }
    })

    // Start the animation
    typingAnimationController.current.start()
  }

  // Effect for loading audio and getting duration
  useEffect(() => {
    if (!missionData?.narration || needsRotation) {
      return
    }

    const audio = audioRef.current

    // Set up audio source
    audio.src = `/assets/${missionData.narration}`

    // Event listener for when audio metadata is loaded (duration available)
    const handleLoadedMetadata = () => {
      const duration = audio.duration
      setAudioDuration(duration)
      console.log('Audio duration loaded:', duration)
    }

    // Event listener for when audio ends
    const handleAudioEnded = () => {
      console.log('Audio playback ended')
    }

    audio.addEventListener('loadedmetadata', handleLoadedMetadata)
    audio.addEventListener('ended', handleAudioEnded)

    // Cleanup
    return () => {
      audio.removeEventListener('loadedmetadata', handleLoadedMetadata)
      audio.removeEventListener('ended', handleAudioEnded)
    }
  }, [missionData?.narration, needsRotation])

  // Effect for typing animation - starts when audio duration is available
  useEffect(() => {
    console.log('missionData', missionData)
    // Check for rotation or missing mission data
    if (
      needsRotation ||
      !missionData ||
      !missionData.message ||
      !missionData.title
    ) {
      // Stop animation if running
      if (typingAnimationController.current) {
        typingAnimationController.current.stop()
      }
      // Stop narration if playing
      if (audioRef.current.src) {
        audioRef.current.pause()
        audioRef.current.currentTime = 0
      }

      // Reset states
      setIsTypingContent(false)
      setShowControls(false)
      setTitleText('') // Clear title if rotating or no data
      setTypedContent('') // Clear content

      // Set default text if data is missing but rotation is ok
      if (!missionData && !needsRotation) {
        setTitleText('Mission Data Missing') // Provide informative title
        setTypedContent('Could not load mission details.')
      }
      return // Exit effect early
    }

    // --- Start Typing Animation ---
    const title = missionData.title
    const content = missionData.message
    const narration = missionData.narration

    // Set title immediately
    setTitleText(title)

    // Wait for audio duration to be available or use fallback
    const initializeAnimationAndAudio = () => {
      const duration = audioDuration > 0 ? audioDuration : 10 // Fallback to 10 seconds if audio duration not available

      console.log('Using duration for typing animation:', duration)

      // Add 1 second delay before starting narration and typing
      const delayTimeout = setTimeout(() => {
        // Play narration after delay
        if (!needsRotation && narration) {
          audioRef.current.currentTime = 0
          audioRef.current.play().catch((err) => {
            console.error('Error playing audio:', err)
          })
        }

        // Start typing animation with the actual audio duration
        startTypingAnimation(content, duration)
      }, 1000) // 1 second delay

      return delayTimeout
    }

    let delayTimeout

    // If audio duration is already available, start immediately
    if (audioDuration > 0) {
      delayTimeout = initializeAnimationAndAudio()
    } else {
      // Wait a bit for audio metadata to load, then start with fallback
      const waitTimeout = setTimeout(() => {
        delayTimeout = initializeAnimationAndAudio()
      }, 100)

      // Cleanup function
      return () => {
        clearTimeout(waitTimeout)
        if (delayTimeout) clearTimeout(delayTimeout)
        if (typingAnimationController.current) {
          typingAnimationController.current.stop()
        }
        setIsTypingContent(false)
      }
    }

    // Cleanup function
    return () => {
      if (delayTimeout) clearTimeout(delayTimeout)
      if (typingAnimationController.current) {
        typingAnimationController.current.stop()
      }
      setIsTypingContent(false) // Ensure state is reset
    }
    // Re-run if mission data changes, rotation status changes, or audio duration changes
  }, [missionData, needsRotation, audioDuration]) // Added audioDuration to dependencies

  const handleFinish = () => {
    playSoundEffect('click')
    if (onComplete) {
      saveProgress()
      onComplete(missionData?.next_scene) // Call the callback passed via props
    } else {
      console.warn('WelcomComponent: onFinish prop not provided.') // Warn if handler is missing
    }
  }

  // --- Component Return ---
  return (
    <>
      {needsRotation && (
        <div className='rotation-overlay'>
          <span className='rotation-icon'>ðŸ”„</span>
          <p>Please rotate your device to landscape mode.</p>
        </div>
      )}
      {!needsRotation && (
        <div
          className='content-container'
          style={{
            backgroundImage: interfaceBG ? `url(${interfaceBG})` : 'none'
          }}
        >
          <div className='final-content-block'>
            {/* Display Title - Ensure titleText state is updated */}
            <h1>{titleText ? titleText.toUpperCase() : 'LOADING...'}</h1>
            <div ref={textContainerRef} className='final-text-area'>
              {typedContent.split('\n').map((line, index) => (
                // Use index for key only if lines don't change order/identity
                <p key={index}>{line || '\u00A0'}</p> // Render empty lines correctly
              ))}
              {/* Cursor visibility based on typing state */}
              <span
                className={`final-cursor ${isTypingContent ? '' : 'hidden'}`}
              >
                _
              </span>
            </div>
          </div>

          {/* Controls (Finish Button) - Conditionally render based on showControls */}

          <div className='final-controls'>
            <button
              style={{
                visibility: showControls ? 'visible' : 'hidden'
              }}
              className='final-button'
              onClick={handleFinish}
            >
              <span className='btn-icon'>
                <FaPlay size={20} />
              </span>{' '}
              START
            </button>
          </div>
          <div className='aza-check-final-image'>
            <img src={characterImage} alt='azabuki' />
          </div>
        </div>
      )}
    </>
  )
}

export default AzabukiCheckComponent
